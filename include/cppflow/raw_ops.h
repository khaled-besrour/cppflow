
/**
 * @file ops.h
 * TensorFlow raw_ops mappings
 */

#ifndef CPPFLOW2_RAW_OPS_H
#define CPPFLOW2_RAW_OPS_H

#include <cstdint>
#include <vector>
#include <limits>
#include <algorithm>

#include <tensorflow/c/eager/c_api.h>
#include <tensorflow/c/tf_datatype.h>
#include <tensorflow/c/tf_tensor.h>

#include "context.h"
#include "tensor.h"
#include "datatype.h"

namespace cppflow {

    tensor abs(const tensor& x);
    tensor accumulate_n_v2(const std::vector<tensor>& inputs, const std::vector<int64_t>& shape);
    tensor accumulator_num_accumulated(const tensor& handle);
    tensor accumulator_take_gradient(const tensor& handle, const tensor& num_required, datatype dtype);
    tensor acos(const tensor& x);
    tensor acosh(const tensor& x);
    tensor add(const tensor& x, const tensor& y);
    tensor add_many_sparse_to_tensors_map(const tensor& sparse_indices, const tensor& sparse_values, const tensor& sparse_shape, const std::string& container = "", const std::string& shared_name = "");
    tensor add_n(const std::vector<tensor>& inputs);
    tensor add_sparse_to_tensors_map(const tensor& sparse_indices, const tensor& sparse_values, const tensor& sparse_shape, const std::string& container = "", const std::string& shared_name = "");
    tensor add_v2(const tensor& x, const tensor& y);
    tensor adjust_contrast(const tensor& images, const tensor& contrast_factor, const tensor& min_value, const tensor& max_value);
    tensor adjust_contrastv2(const tensor& images, const tensor& contrast_factor);
    tensor adjust_hue(const tensor& images, const tensor& delta);
    tensor adjust_saturation(const tensor& images, const tensor& scale);
    tensor all(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor all_to_all(const tensor& input, const tensor& group_assignment, int64_t concat_dimension, int64_t split_dimension, int64_t split_count);
    tensor angle(const tensor& input, datatype Tout = static_cast<datatype>(1));
    tensor anonymous_iterator(const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor any(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor apply_ada_max(const tensor& var, const tensor& m, const tensor& v, const tensor& beta1_power, const tensor& lr, const tensor& beta1, const tensor& beta2, const tensor& epsilon, const tensor& grad, bool use_locking = false);
    tensor apply_adadelta(const tensor& var, const tensor& accum, const tensor& accum_update, const tensor& lr, const tensor& rho, const tensor& epsilon, const tensor& grad, bool use_locking = false);
    tensor apply_adagrad(const tensor& var, const tensor& accum, const tensor& lr, const tensor& grad, bool use_locking = false, bool update_slots = true);
    tensor apply_adagrad_d_a(const tensor& var, const tensor& gradient_accumulator, const tensor& gradient_squared_accumulator, const tensor& grad, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& global_step, bool use_locking = false);
    tensor apply_adagrad_v2(const tensor& var, const tensor& accum, const tensor& lr, const tensor& epsilon, const tensor& grad, bool use_locking = false, bool update_slots = true);
    tensor apply_adam(const tensor& var, const tensor& m, const tensor& v, const tensor& beta1_power, const tensor& beta2_power, const tensor& lr, const tensor& beta1, const tensor& beta2, const tensor& epsilon, const tensor& grad, bool use_locking = false, bool use_nesterov = false);
    tensor apply_add_sign(const tensor& var, const tensor& m, const tensor& lr, const tensor& alpha, const tensor& sign_decay, const tensor& beta, const tensor& grad, bool use_locking = false);
    tensor apply_centered_r_m_s_prop(const tensor& var, const tensor& mg, const tensor& ms, const tensor& mom, const tensor& lr, const tensor& rho, const tensor& momentum, const tensor& epsilon, const tensor& grad, bool use_locking = false);
    tensor apply_ftrl(const tensor& var, const tensor& accum, const tensor& linear, const tensor& grad, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& lr_power, bool use_locking = false, bool multiply_linear_by_lr = false);
    tensor apply_ftrl_v2(const tensor& var, const tensor& accum, const tensor& linear, const tensor& grad, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& l2_shrinkage, const tensor& lr_power, bool use_locking = false, bool multiply_linear_by_lr = false);
    tensor apply_gradient_descent(const tensor& var, const tensor& alpha, const tensor& delta, bool use_locking = false);
    tensor apply_momentum(const tensor& var, const tensor& accum, const tensor& lr, const tensor& grad, const tensor& momentum, bool use_locking = false, bool use_nesterov = false);
    tensor apply_power_sign(const tensor& var, const tensor& m, const tensor& lr, const tensor& logbase, const tensor& sign_decay, const tensor& beta, const tensor& grad, bool use_locking = false);
    tensor apply_proximal_adagrad(const tensor& var, const tensor& accum, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& grad, bool use_locking = false);
    tensor apply_proximal_gradient_descent(const tensor& var, const tensor& alpha, const tensor& l1, const tensor& l2, const tensor& delta, bool use_locking = false);
    tensor apply_r_m_s_prop(const tensor& var, const tensor& ms, const tensor& mom, const tensor& lr, const tensor& rho, const tensor& momentum, const tensor& epsilon, const tensor& grad, bool use_locking = false);
    tensor approximate_equal(const tensor& x, const tensor& y, float tolerance = 1.0000e-05);
    tensor arg_max(const tensor& input, const tensor& dimension, datatype Tidx = static_cast<datatype>(3), datatype output_type = static_cast<datatype>(9));
    tensor arg_min(const tensor& input, const tensor& dimension, datatype Tidx = static_cast<datatype>(3), datatype output_type = static_cast<datatype>(9));
    tensor as_string(const tensor& input, int64_t precision = -1, bool scientific = false, bool shortest = false, int64_t width = -1, const std::string& fill = "");
    tensor asin(const tensor& x);
    tensor asinh(const tensor& x);
    tensor assert_cardinality_dataset(const tensor& input_dataset, const tensor& cardinality, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor assert_next_dataset(const tensor& input_dataset, const tensor& transformations, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor assign(const tensor& ref, const tensor& value, bool validate_shape = true, bool use_locking = true);
    tensor assign_add(const tensor& ref, const tensor& value, bool use_locking = false);
    tensor assign_sub(const tensor& ref, const tensor& value, bool use_locking = false);
    tensor atan(const tensor& x);
    tensor atan2(const tensor& y, const tensor& x);
    tensor atanh(const tensor& x);
    tensor audio_spectrogram(const tensor& input, int64_t window_size, int64_t stride, bool magnitude_squared = false);
    tensor audio_summary(const tensor& tag, const tensor& input_tensor, float sample_rate, int64_t max_outputs = 3);
    tensor audio_summary_v2(const tensor& tag, const tensor& input_tensor, const tensor& sample_rate, int64_t max_outputs = 3);
    tensor auto_shard_dataset(const tensor& input_dataset, const tensor& num_workers, const tensor& index, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, int64_t auto_shard_policy = 0);
    tensor avg_pool(const tensor& value, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor avg_pool3_d(const tensor& input, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NDHWC");
    tensor avg_pool3_d_grad(const tensor& orig_input_shape, const tensor& grad, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NDHWC");
    tensor avg_pool_grad(const tensor& orig_input_shape, const tensor& grad, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor barrier(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor barrier_incomplete_size(const tensor& handle);
    tensor barrier_ready_size(const tensor& handle);
    tensor batch_cholesky(const tensor& input);
    tensor batch_cholesky_grad(const tensor& l, const tensor& grad);
    tensor batch_dataset(const tensor& input_dataset, const tensor& batch_size, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor batch_dataset_v2(const tensor& input_dataset, const tensor& batch_size, const tensor& drop_remainder, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool parallel_copy = false);
    tensor batch_f_f_t(const tensor& input);
    tensor batch_f_f_t2_d(const tensor& input);
    tensor batch_f_f_t3_d(const tensor& input);
    tensor batch_i_f_f_t(const tensor& input);
    tensor batch_i_f_f_t2_d(const tensor& input);
    tensor batch_i_f_f_t3_d(const tensor& input);
    tensor batch_mat_mul(const tensor& x, const tensor& y, bool adj_x = false, bool adj_y = false);
    tensor batch_mat_mul_v2(const tensor& x, const tensor& y, bool adj_x = false, bool adj_y = false);
    tensor batch_matrix_band_part(const tensor& input, const tensor& num_lower, const tensor& num_upper);
    tensor batch_matrix_determinant(const tensor& input);
    tensor batch_matrix_diag(const tensor& diagonal);
    tensor batch_matrix_diag_part(const tensor& input);
    tensor batch_matrix_inverse(const tensor& input, bool adjoint = false);
    tensor batch_matrix_set_diag(const tensor& input, const tensor& diagonal);
    tensor batch_matrix_solve(const tensor& matrix, const tensor& rhs, bool adjoint = false);
    tensor batch_matrix_solve_ls(const tensor& matrix, const tensor& rhs, const tensor& l2_regularizer, bool fast = true);
    tensor batch_matrix_triangular_solve(const tensor& matrix, const tensor& rhs, bool lower = true, bool adjoint = false);
    tensor batch_norm_with_global_normalization(const tensor& t, const tensor& m, const tensor& v, const tensor& beta, const tensor& gamma, float variance_epsilon, bool scale_after_normalization);
    tensor batch_self_adjoint_eig(const tensor& input);
    tensor batch_to_space(const tensor& input, const tensor& crops, int64_t block_size, datatype Tidx = static_cast<datatype>(3));
    tensor batch_to_space_n_d(const tensor& input, const tensor& block_shape, const tensor& crops, datatype Tblock_shape = static_cast<datatype>(3), datatype Tcrops = static_cast<datatype>(3));
    tensor bessel_i0e(const tensor& x);
    tensor bessel_i1e(const tensor& x);
    tensor betainc(const tensor& a, const tensor& b, const tensor& x);
    tensor bias_add(const tensor& value, const tensor& bias, const std::string& data_format = "NHWC");
    tensor bias_add_grad(const tensor& out_backprop, const std::string& data_format = "NHWC");
    tensor bias_add_v1(const tensor& value, const tensor& bias);
    tensor bincount(const tensor& arr, const tensor& size, const tensor& weights);
    tensor bitcast(const tensor& input, datatype type);
    tensor bitwise_and(const tensor& x, const tensor& y);
    tensor bitwise_or(const tensor& x, const tensor& y);
    tensor bitwise_xor(const tensor& x, const tensor& y);
    tensor boosted_trees_aggregate_stats(const tensor& node_ids, const tensor& gradients, const tensor& hessians, const tensor& feature, int64_t max_splits, int64_t num_buckets);
    tensor boosted_trees_bucketize(const std::vector<tensor>& float_values, const std::vector<tensor>& bucket_boundaries);
    tensor boosted_trees_center_bias(const tensor& tree_ensemble_handle, const tensor& mean_gradients, const tensor& mean_hessians, const tensor& l1, const tensor& l2);
    tensor boosted_trees_ensemble_resource_handle_op(const std::string& container = "", const std::string& shared_name = "");
    tensor boosted_trees_example_debug_outputs(const tensor& tree_ensemble_handle, const std::vector<tensor>& bucketized_features, int64_t logits_dimension);
    tensor boosted_trees_flush_quantile_summaries(const tensor& quantile_stream_resource_handle, int64_t num_features);
    tensor boosted_trees_make_quantile_summaries(const std::vector<tensor>& float_values, const tensor& example_weights, const tensor& epsilon);
    tensor boosted_trees_make_stats_summary(const tensor& node_ids, const tensor& gradients, const tensor& hessians, const std::vector<tensor>& bucketized_features_list, int64_t max_splits, int64_t num_buckets);
    tensor boosted_trees_predict(const tensor& tree_ensemble_handle, const std::vector<tensor>& bucketized_features, int64_t logits_dimension);
    tensor boosted_trees_quantile_stream_resource_get_bucket_boundaries(const tensor& quantile_stream_resource_handle, int64_t num_features);
    tensor boosted_trees_quantile_stream_resource_handle_op(const std::string& container = "", const std::string& shared_name = "");
    tensor broadcast_args(const tensor& s0, const tensor& s1);
    tensor broadcast_to(const tensor& input, const tensor& shape, datatype Tidx = static_cast<datatype>(3));
    tensor bucketize(const tensor& input, const std::vector<float>& boundaries);
    tensor bytes_produced_stats_dataset(const tensor& input_dataset, const tensor& tag, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor c_s_r_sparse_matrix_to_dense(const tensor& sparse_input, datatype type);
    tensor c_s_v_dataset(const tensor& filenames, const tensor& compression_type, const tensor& buffer_size, const tensor& header, const tensor& field_delim, const tensor& use_quote_delim, const tensor& na_value, const tensor& select_cols, const std::vector<tensor>& record_defaults, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor cache_dataset(const tensor& input_dataset, const tensor& filename, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor cache_dataset_v2(const tensor& input_dataset, const tensor& filename, const tensor& cache, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor cast(const tensor& x, datatype SrcT, datatype DstT, bool Truncate = false);
    tensor ceil(const tensor& x);
    tensor check_numerics(const tensor& input_tensor, const std::string& message);
    tensor check_numerics_v2(const tensor& input_tensor, const std::string& message);
    tensor cholesky(const tensor& input);
    tensor cholesky_grad(const tensor& l, const tensor& grad);
    tensor choose_fastest_dataset(const std::vector<tensor>& input_datasets, int64_t num_experiments, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor clip_by_value(const tensor& t, const tensor& clip_value_min, const tensor& clip_value_max);
    tensor collective_bcast_recv(int64_t group_size, int64_t group_key, int64_t instance_key, const std::vector<int64_t>& shape, const std::string& communication_hint = "auto", float timeout_seconds = 0.0000e+00);
    tensor collective_bcast_send(const tensor& input, int64_t group_size, int64_t group_key, int64_t instance_key, const std::vector<int64_t>& shape, const std::string& communication_hint = "auto", float timeout_seconds = 0.0000e+00);
    tensor collective_gather(const tensor& input, int64_t group_size, int64_t group_key, int64_t instance_key, const std::vector<int64_t>& shape, const std::string& communication_hint = "auto", float timeout_seconds = 0.0000e+00);
    tensor collective_permute(const tensor& input, const tensor& source_target_pairs);
    tensor collective_reduce(const tensor& input, int64_t group_size, int64_t group_key, int64_t instance_key, const std::string& merge_op, const std::string& final_op, const std::vector<int64_t>& subdiv_offsets, const std::vector<int64_t>& wait_for, const std::string& communication_hint = "auto", float timeout_seconds = 0.0000e+00);
    tensor compare_and_bitpack(const tensor& input, const tensor& threshold);
    tensor complex(const tensor& real, const tensor& imag, datatype Tout = static_cast<datatype>(8));
    tensor complex_abs(const tensor& x, datatype Tout = static_cast<datatype>(1));
    tensor concat(const tensor& concat_dim, const std::vector<tensor>& values);
    tensor concat_offset(const tensor& concat_dim, const std::vector<tensor>& shape);
    tensor concat_v2(const std::vector<tensor>& values, const tensor& axis, datatype Tidx = static_cast<datatype>(3));
    tensor concatenate_dataset(const tensor& input_dataset, const tensor& another_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor conditional_accumulator(datatype dtype, const std::vector<int64_t>& shape, const std::string& container = "", const std::string& shared_name = "", const std::string& reduction_type = "MEAN");
    tensor configure_distributed_t_p_u(const std::string& embedding_config = "", const std::string& tpu_embedding_config = "", bool is_global_init = false, bool enable_whole_mesh_compilations = false, bool compilation_failure_closes_chips = true);
    tensor conj(const tensor& input);
    tensor conjugate_transpose(const tensor& x, const tensor& perm, datatype Tperm = static_cast<datatype>(3));
    tensor const_tensor(const tensor& value, datatype dtype);
    tensor conv2_d(const tensor& input, const tensor& filter, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& explicit_paddings, const std::vector<int64_t>& dilations, bool use_cudnn_on_gpu = true, const std::string& data_format = "NHWC");
    tensor conv2_d_backprop_filter(const tensor& input, const tensor& filter_sizes, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& explicit_paddings, const std::vector<int64_t>& dilations, bool use_cudnn_on_gpu = true, const std::string& data_format = "NHWC");
    tensor conv2_d_backprop_input(const tensor& input_sizes, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& explicit_paddings, const std::vector<int64_t>& dilations, bool use_cudnn_on_gpu = true, const std::string& data_format = "NHWC");
    tensor conv3_d(const tensor& input, const tensor& filter, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& dilations, const std::string& data_format = "NDHWC");
    tensor conv3_d_backprop_filter(const tensor& input, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& dilations);
    tensor conv3_d_backprop_filter_v2(const tensor& input, const tensor& filter_sizes, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& dilations, const std::string& data_format = "NDHWC");
    tensor conv3_d_backprop_input(const tensor& input, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& dilations);
    tensor conv3_d_backprop_input_v2(const tensor& input_sizes, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& dilations, const std::string& data_format = "NDHWC", datatype Tshape = static_cast<datatype>(3));
    tensor copy(const tensor& input, const std::vector< std::string>& debug_ops_spec, const std::string& tensor_name = "");
    tensor copy_host(const tensor& input, const std::vector< std::string>& debug_ops_spec, const std::string& tensor_name = "");
    tensor cos(const tensor& x);
    tensor cosh(const tensor& x);
    tensor count_up_to(const tensor& ref, int64_t limit);
    tensor crop_and_resize(const tensor& image, const tensor& boxes, const tensor& box_ind, const tensor& crop_size, const std::string& method = "bilinear", float extrapolation_value = 0.0000e+00);
    tensor crop_and_resize_grad_boxes(const tensor& grads, const tensor& image, const tensor& boxes, const tensor& box_ind, const std::string& method = "bilinear");
    tensor crop_and_resize_grad_image(const tensor& grads, const tensor& boxes, const tensor& box_ind, const tensor& image_size, const std::string& method = "bilinear");
    tensor cross(const tensor& a, const tensor& b);
    tensor cross_replica_sum(const tensor& input, const tensor& group_assignment);
    tensor cudnn_r_n_n_canonical_to_params(const tensor& num_layers, const tensor& num_units, const tensor& input_size, const std::vector<tensor>& weights, const std::vector<tensor>& biases, const std::string& rnn_mode = "lstm", const std::string& input_mode = "linear_input", const std::string& direction = "unidirectional", float dropout = 0.0000e+00, int64_t seed = 0, int64_t seed2 = 0);
    tensor cudnn_r_n_n_canonical_to_params_v2(const tensor& num_layers, const tensor& num_units, const tensor& input_size, const std::vector<tensor>& weights, const std::vector<tensor>& biases, const std::string& rnn_mode = "lstm", const std::string& input_mode = "linear_input", const std::string& direction = "unidirectional", float dropout = 0.0000e+00, int64_t seed = 0, int64_t seed2 = 0, int64_t num_proj = 0);
    tensor cudnn_r_n_n_params_size(const tensor& num_layers, const tensor& num_units, const tensor& input_size, datatype S, const std::string& rnn_mode = "lstm", const std::string& input_mode = "linear_input", const std::string& direction = "unidirectional", float dropout = 0.0000e+00, int64_t seed = 0, int64_t seed2 = 0, int64_t num_proj = 0);
    tensor cumprod(const tensor& x, const tensor& axis, bool exclusive = false, bool reverse = false, datatype Tidx = static_cast<datatype>(3));
    tensor cumsum(const tensor& x, const tensor& axis, bool exclusive = false, bool reverse = false, datatype Tidx = static_cast<datatype>(3));
    tensor cumulative_logsumexp(const tensor& x, const tensor& axis, bool exclusive = false, bool reverse = false, datatype Tidx = static_cast<datatype>(3));
    tensor data_format_dim_map(const tensor& x, const std::string& src_format = "NHWC", const std::string& dst_format = "NCHW");
    tensor data_format_vec_permute(const tensor& x, const std::string& src_format = "NHWC", const std::string& dst_format = "NCHW");
    tensor dataset_cardinality(const tensor& input_dataset);
    tensor dataset_from_graph(const tensor& graph_def);
    tensor dataset_to_graph(const tensor& input_dataset, const std::vector< std::string>& stateful_whitelist, bool allow_stateful = false, bool strip_device_assignment = false);
    tensor dataset_to_graph_v2(const tensor& input_dataset, int64_t external_state_policy = 0, bool strip_device_assignment = false);
    tensor dataset_to_single_element(const tensor& dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor dawsn(const tensor& x);
    tensor debug_gradient_identity(const tensor& input);
    tensor debug_gradient_ref_identity(const tensor& input);
    tensor debug_identity(const tensor& input, const std::vector< std::string>& debug_urls, const std::string& device_name = "", const std::string& tensor_name = "", bool gated_grpc = false);
    tensor debug_identity_v2(const tensor& input, const std::vector< std::string>& debug_urls, const std::string& tfdbg_context_id = "", const std::string& op_name = "", int64_t output_slot = -1, int64_t tensor_debug_mode = -1, int64_t circular_buffer_size = 1000, const std::string& tfdbg_run_id = "");
    tensor debug_nan_count(const tensor& input, const std::vector< std::string>& debug_urls, const std::string& device_name = "", const std::string& tensor_name = "", bool gated_grpc = false);
    tensor debug_numeric_summary(const tensor& input, const std::vector< std::string>& debug_urls, const std::string& device_name = "", const std::string& tensor_name = "", float lower_bound = -std::numeric_limits<float>::infinity(), float upper_bound = std::numeric_limits<float>::infinity(), bool mute_if_healthy = false, bool gated_grpc = false);
    tensor debug_numeric_summary_v2(const tensor& input, datatype output_dtype = static_cast<datatype>(1), int64_t tensor_debug_mode = -1, int64_t tensor_id = -1);
    tensor decode_and_crop_jpeg(const tensor& contents, const tensor& crop_window, int64_t channels = 0, int64_t ratio = 1, bool fancy_upscaling = true, bool try_recover_truncated = false, float acceptable_fraction = 1.0000e+00, const std::string& dct_method = "");
    tensor decode_base64(const tensor& input);
    tensor decode_bmp(const tensor& contents, int64_t channels = 0);
    tensor decode_c_s_v(const tensor& records, const std::vector<tensor>& record_defaults, const std::vector<datatype>& OUT_TYPE, const std::vector<int64_t>& select_cols, const std::string& field_delim = ",", bool use_quote_delim = true, const std::string& na_value = "");
    tensor decode_compressed(const tensor& bytes, const std::string& compression_type = "");
    tensor decode_gif(const tensor& contents);
    tensor decode_j_s_o_n_example(const tensor& json_examples);
    tensor decode_jpeg(const tensor& contents, int64_t channels = 0, int64_t ratio = 1, bool fancy_upscaling = true, bool try_recover_truncated = false, float acceptable_fraction = 1.0000e+00, const std::string& dct_method = "");
    tensor decode_padded_raw(const tensor& input_bytes, const tensor& fixed_length, datatype out_type, bool little_endian = true);
    tensor decode_png(const tensor& contents, int64_t channels = 0, datatype dtype = static_cast<datatype>(4));
    tensor decode_raw(const tensor& bytes, datatype out_type, bool little_endian = true);
    tensor deep_copy(const tensor& x);
    tensor dense_to_c_s_r_sparse_matrix(const tensor& dense_input, const tensor& indices);
    tensor dense_to_sparse_batch_dataset(const tensor& input_dataset, const tensor& batch_size, const tensor& row_shape, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor depth_to_space(const tensor& input, int64_t block_size, const std::string& data_format = "NHWC");
    tensor depthwise_conv2d_native(const tensor& input, const tensor& filter, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& explicit_paddings, const std::vector<int64_t>& dilations, const std::string& data_format = "NHWC");
    tensor depthwise_conv2d_native_backprop_filter(const tensor& input, const tensor& filter_sizes, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& explicit_paddings, const std::vector<int64_t>& dilations, const std::string& data_format = "NHWC");
    tensor depthwise_conv2d_native_backprop_input(const tensor& input_sizes, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::string& padding, const std::vector<int64_t>& explicit_paddings, const std::vector<int64_t>& dilations, const std::string& data_format = "NHWC");
    tensor dequantize(const tensor& input, const tensor& min_range, const tensor& max_range, const std::string& mode = "MIN_COMBINED", bool narrow_range = false, int64_t axis = -1, datatype dtype = static_cast<datatype>(1));
    tensor destroy_temporary_variable(const tensor& ref, const std::string& var_name);
    tensor diag(const tensor& diagonal);
    tensor diag_part(const tensor& input);
    tensor digamma(const tensor& x);
    tensor dilation2_d(const tensor& input, const tensor& filter, const std::vector<int64_t>& strides, const std::vector<int64_t>& rates, const std::string& padding);
    tensor dilation2_d_backprop_filter(const tensor& input, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::vector<int64_t>& rates, const std::string& padding);
    tensor dilation2_d_backprop_input(const tensor& input, const tensor& filter, const tensor& out_backprop, const std::vector<int64_t>& strides, const std::vector<int64_t>& rates, const std::string& padding);
    tensor directed_interleave_dataset(const tensor& selector_input_dataset, const std::vector<tensor>& data_input_datasets, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor div(const tensor& x, const tensor& y);
    tensor div_no_nan(const tensor& x, const tensor& y);
    tensor draw_bounding_boxes(const tensor& images, const tensor& boxes);
    tensor draw_bounding_boxes_v2(const tensor& images, const tensor& boxes, const tensor& colors);
    tensor dummy_memory_cache();
    tensor dynamic_partition(const tensor& data, const tensor& partitions, int64_t num_partitions);
    tensor dynamic_stitch(const std::vector<tensor>& indices, const std::vector<tensor>& data);
    tensor eager_py_func(const std::vector<tensor>& input, const std::string& token, const std::vector<datatype>& Tin, const std::vector<datatype>& Tout, bool is_async = false);
    tensor edit_distance(const tensor& hypothesis_indices, const tensor& hypothesis_values, const tensor& hypothesis_shape, const tensor& truth_indices, const tensor& truth_values, const tensor& truth_shape, bool normalize = true);
    tensor einsum(const std::vector<tensor>& inputs, const std::string& equation);
    tensor elu(const tensor& features);
    tensor elu_grad(const tensor& gradients, const tensor& outputs);
    tensor empty(const tensor& shape, datatype dtype, bool init = false);
    tensor empty_tensor_list(const tensor& element_shape, const tensor& max_num_elements, datatype element_dtype, datatype shape_type);
    tensor encode_base64(const tensor& input, bool pad = false);
    tensor encode_jpeg(const tensor& image, const std::string& format = "", int64_t quality = 95, bool progressive = false, bool optimize_size = false, bool chroma_downsampling = true, const std::string& density_unit = "in", int64_t x_density = 300, int64_t y_density = 300, const std::string& xmp_metadata = "");
    tensor encode_jpeg_variable_quality(const tensor& images, const tensor& quality);
    tensor encode_png(const tensor& image, int64_t compression = -1);
    tensor encode_proto(const tensor& sizes, const std::vector<tensor>& values, const std::vector< std::string>& field_names, const std::string& message_type, const std::vector<datatype>& Tinput_types, const std::string& descriptor_source = "local://");
    tensor encode_wav(const tensor& audio, const tensor& sample_rate);
    tensor ensure_shape(const tensor& input, const std::vector<int64_t>& shape);
    tensor enter(const tensor& data, const std::string& frame_name, bool is_constant = false, int64_t parallel_iterations = 10);
    tensor equal(const tensor& x, const tensor& y, bool incompatible_shape_error = true);
    tensor erf(const tensor& x);
    tensor erfc(const tensor& x);
    tensor erfinv(const tensor& x);
    tensor euclidean_norm(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor exit(const tensor& data);
    tensor exp(const tensor& x);
    tensor expand_dims(const tensor& input, const tensor& dim, datatype Tdim = static_cast<datatype>(3));
    tensor experimental_assert_next_dataset(const tensor& input_dataset, const tensor& transformations, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_auto_shard_dataset(const tensor& input_dataset, const tensor& num_workers, const tensor& index, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, int64_t auto_shard_policy = 0);
    tensor experimental_bytes_produced_stats_dataset(const tensor& input_dataset, const tensor& tag, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_c_s_v_dataset(const tensor& filenames, const tensor& compression_type, const tensor& buffer_size, const tensor& header, const tensor& field_delim, const tensor& use_quote_delim, const tensor& na_value, const tensor& select_cols, const std::vector<tensor>& record_defaults, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_choose_fastest_dataset(const std::vector<tensor>& input_datasets, int64_t num_experiments, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_dataset_cardinality(const tensor& input_dataset);
    tensor experimental_dense_to_sparse_batch_dataset(const tensor& input_dataset, const tensor& batch_size, const tensor& row_shape, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_directed_interleave_dataset(const tensor& selector_input_dataset, const std::vector<tensor>& data_input_datasets, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_ignore_errors_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_iterator_get_device(const tensor& resource);
    tensor experimental_l_m_d_b_dataset(const tensor& filenames, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_latency_stats_dataset(const tensor& input_dataset, const tensor& tag, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_matching_files_dataset(const tensor& patterns);
    tensor experimental_max_intra_op_parallelism_dataset(const tensor& input_dataset, const tensor& max_intra_op_parallelism, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_non_serializable_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_parse_example_dataset(const tensor& input_dataset, const tensor& num_parallel_calls, const std::vector<tensor>& dense_defaults, const std::vector< std::string>& sparse_keys, const std::vector< std::string>& dense_keys, const std::vector<datatype>& sparse_types, const std::vector<datatype>& Tdense, const std::vector< std::vector<int64_t>>& dense_shapes, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool sloppy = false);
    tensor experimental_private_thread_pool_dataset(const tensor& input_dataset, const tensor& num_threads, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_random_dataset(const tensor& seed, const tensor& seed2, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_rebatch_dataset(const tensor& input_dataset, const tensor& num_replicas, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool use_fallback = true);
    tensor experimental_set_stats_aggregator_dataset(const tensor& input_dataset, const tensor& stats_aggregator, const tensor& tag, const tensor& counter_prefix, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_sleep_dataset(const tensor& input_dataset, const tensor& sleep_microseconds, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_sliding_window_dataset(const tensor& input_dataset, const tensor& window_size, const tensor& window_shift, const tensor& window_stride, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_sql_dataset(const tensor& driver_name, const tensor& data_source_name, const tensor& query, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_stats_aggregator_handle(const std::string& container = "", const std::string& shared_name = "");
    tensor experimental_stats_aggregator_summary(const tensor& iterator);
    tensor experimental_thread_pool_dataset(const tensor& input_dataset, const tensor& thread_pool, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_thread_pool_handle(int64_t num_threads, const std::string& display_name, int64_t max_intra_op_parallelism = 1, const std::string& container = "", const std::string& shared_name = "");
    tensor experimental_unbatch_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor experimental_unique_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor expint(const tensor& x);
    tensor expm1(const tensor& x);
    tensor extract_glimpse(const tensor& input, const tensor& size, const tensor& offsets, bool centered = true, bool normalized = true, bool uniform_noise = true, const std::string& noise = "uniform");
    tensor extract_image_patches(const tensor& images, const std::vector<int64_t>& ksizes, const std::vector<int64_t>& strides, const std::vector<int64_t>& rates, const std::string& padding);
    tensor extract_jpeg_shape(const tensor& contents, datatype output_type = static_cast<datatype>(3));
    tensor extract_volume_patches(const tensor& input, const std::vector<int64_t>& ksizes, const std::vector<int64_t>& strides, const std::string& padding);
    tensor f_f_t(const tensor& input, datatype Tcomplex = static_cast<datatype>(8));
    tensor f_f_t2_d(const tensor& input, datatype Tcomplex = static_cast<datatype>(8));
    tensor f_f_t3_d(const tensor& input, datatype Tcomplex = static_cast<datatype>(8));
    tensor f_i_f_o_queue(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor f_i_f_o_queue_v2(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor fact();
    tensor fake_param(datatype dtype, const std::vector<int64_t>& shape);
    tensor fake_quant_with_min_max_args(const tensor& inputs, float min = -6.0000e+00, float max = 6.0000e+00, int64_t num_bits = 8, bool narrow_range = false);
    tensor fake_quant_with_min_max_args_gradient(const tensor& gradients, const tensor& inputs, float min = -6.0000e+00, float max = 6.0000e+00, int64_t num_bits = 8, bool narrow_range = false);
    tensor fake_quant_with_min_max_vars(const tensor& inputs, const tensor& min, const tensor& max, int64_t num_bits = 8, bool narrow_range = false);
    tensor fake_quant_with_min_max_vars_per_channel(const tensor& inputs, const tensor& min, const tensor& max, int64_t num_bits = 8, bool narrow_range = false);
    tensor fake_queue(const tensor& resource);
    tensor fill(const tensor& dims, const tensor& value, datatype index_type = static_cast<datatype>(3));
    tensor filter_by_last_component_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor fingerprint(const tensor& data, const tensor& method);
    tensor fixed_length_record_dataset(const tensor& filenames, const tensor& header_bytes, const tensor& record_bytes, const tensor& footer_bytes, const tensor& buffer_size);
    tensor fixed_length_record_dataset_v2(const tensor& filenames, const tensor& header_bytes, const tensor& record_bytes, const tensor& footer_bytes, const tensor& buffer_size, const tensor& compression_type);
    tensor fixed_length_record_reader(int64_t record_bytes, int64_t header_bytes = 0, int64_t footer_bytes = 0, int64_t hop_bytes = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor fixed_length_record_reader_v2(int64_t record_bytes, int64_t header_bytes = 0, int64_t footer_bytes = 0, int64_t hop_bytes = 0, const std::string& container = "", const std::string& shared_name = "", const std::string& encoding = "");
    tensor floor(const tensor& x);
    tensor floor_div(const tensor& x, const tensor& y);
    tensor floor_mod(const tensor& x, const tensor& y);
    tensor fractional_avg_pool_grad(const tensor& orig_input_input_tensor_shape, const tensor& out_backprop, const tensor& row_pooling_sequence, const tensor& col_pooling_sequence, bool overlapping = false);
    tensor fractional_max_pool_grad(const tensor& orig_input, const tensor& orig_output, const tensor& out_backprop, const tensor& row_pooling_sequence, const tensor& col_pooling_sequence, bool overlapping = false);
    tensor fresnel_cos(const tensor& x);
    tensor fresnel_sin(const tensor& x);
    tensor fused_pad_conv2_d(const tensor& input, const tensor& paddings, const tensor& filter, const std::string& mode, const std::vector<int64_t>& strides, const std::string& padding);
    tensor fused_resize_and_pad_conv2_d(const tensor& input, const tensor& size, const tensor& paddings, const tensor& filter, const std::string& mode, const std::vector<int64_t>& strides, const std::string& padding, bool resize_align_corners = false);
    tensor gather(const tensor& params, const tensor& indices, datatype Tparams, datatype Tindices, bool validate_indices = true);
    tensor gather_nd(const tensor& params, const tensor& indices, datatype Tparams, datatype Tindices);
    tensor gather_v2(const tensor& params, const tensor& indices, const tensor& axis, datatype Tparams, datatype Tindices, datatype Taxis, int64_t batch_dims = 0);
    tensor get_session_handle(const tensor& value);
    tensor get_session_handle_v2(const tensor& value);
    tensor get_session_tensor(const tensor& handle, datatype dtype);
    tensor greater(const tensor& x, const tensor& y);
    tensor greater_equal(const tensor& x, const tensor& y);
    tensor guarantee_const_tensor(const tensor& input);
    tensor h_s_v_to_r_g_b(const tensor& images);
    tensor hash_table(datatype key_dtype, datatype value_dtype, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false);
    tensor hash_table_v2(datatype key_dtype, datatype value_dtype, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false);
    tensor histogram_fixed_width(const tensor& values, const tensor& value_range, const tensor& nbins, datatype dtype = static_cast<datatype>(3));
    tensor histogram_summary(const tensor& tag, const tensor& values);
    tensor i_f_f_t(const tensor& input, datatype Tcomplex = static_cast<datatype>(8));
    tensor i_f_f_t2_d(const tensor& input, datatype Tcomplex = static_cast<datatype>(8));
    tensor i_f_f_t3_d(const tensor& input, datatype Tcomplex = static_cast<datatype>(8));
    tensor i_r_f_f_t(const tensor& input, const tensor& fft_length, datatype Treal = static_cast<datatype>(1), datatype Tcomplex = static_cast<datatype>(8));
    tensor i_r_f_f_t2_d(const tensor& input, const tensor& fft_length, datatype Treal = static_cast<datatype>(1), datatype Tcomplex = static_cast<datatype>(8));
    tensor i_r_f_f_t3_d(const tensor& input, const tensor& fft_length, datatype Treal = static_cast<datatype>(1), datatype Tcomplex = static_cast<datatype>(8));
    tensor identity(const tensor& input);
    tensor identity_n(const std::vector<tensor>& input);
    tensor identity_reader(const std::string& container = "", const std::string& shared_name = "");
    tensor identity_reader_v2(const std::string& container = "", const std::string& shared_name = "");
    tensor igamma(const tensor& a, const tensor& x);
    tensor igamma_grad_a(const tensor& a, const tensor& x);
    tensor igammac(const tensor& a, const tensor& x);
    tensor ignore_errors_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor imag(const tensor& input, datatype Tout = static_cast<datatype>(1));
    tensor image_projective_transform_v2(const tensor& images, const tensor& transforms, const tensor& output_shape, datatype dtype, const std::string& interpolation, const std::string& fill_mode = "CONSTANT");
    tensor image_summary(const tensor& tag, const tensor& input_tensor, const tensor& bad_color, int64_t max_images = 3);
    tensor immutable_const_tensor(datatype dtype, const std::vector<int64_t>& shape, const std::string& memory_region_name);
    tensor in_top_k(const tensor& predictions, const tensor& targets, int64_t k);
    tensor in_top_k_v2(const tensor& predictions, const tensor& targets, const tensor& k);
    tensor infeed_dequeue(datatype dtype, const std::vector<int64_t>& shape);
    tensor infeed_dequeue_tuple(const std::vector<datatype>& dtypes, const std::vector< std::vector<int64_t>>& shapes);
    tensor inplace_add(const tensor& x, const tensor& i, const tensor& v);
    tensor inplace_sub(const tensor& x, const tensor& i, const tensor& v);
    tensor inplace_update(const tensor& x, const tensor& i, const tensor& v);
    tensor inv(const tensor& x);
    tensor inv_grad(const tensor& y, const tensor& dy);
    tensor invert(const tensor& x);
    tensor invert_permutation(const tensor& x);
    tensor is_boosted_trees_ensemble_initialized(const tensor& tree_ensemble_handle);
    tensor is_boosted_trees_quantile_stream_resource_initialized(const tensor& quantile_stream_resource_handle);
    tensor is_finite(const tensor& x);
    tensor is_inf(const tensor& x);
    tensor is_nan(const tensor& x);
    tensor is_variable_initialized(const tensor& ref, datatype dtype);
    tensor iterator(const std::string& shared_name, const std::string& container, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor iterator_from_string_handle(const tensor& string_handle, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor iterator_from_string_handle_v2(const tensor& string_handle, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor iterator_get_device(const tensor& resource);
    tensor iterator_get_next(const tensor& iterator, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor iterator_get_next_as_optional(const tensor& iterator, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor iterator_get_next_sync(const tensor& iterator, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor iterator_to_string_handle(const tensor& resource_handle);
    tensor iterator_v2(const std::string& shared_name, const std::string& container, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor l2_loss(const tensor& t);
    tensor l_m_d_b_dataset(const tensor& filenames, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor l_m_d_b_reader(const std::string& container = "", const std::string& shared_name = "");
    tensor l_r_n(const tensor& input, int64_t depth_radius = 5, float bias = 1.0000e+00, float alpha = 1.0000e+00, float beta = 5.0000e-01);
    tensor l_r_n_grad(const tensor& input_grads, const tensor& input_image, const tensor& output_image, int64_t depth_radius = 5, float bias = 1.0000e+00, float alpha = 1.0000e+00, float beta = 5.0000e-01);
    tensor latency_stats_dataset(const tensor& input_dataset, const tensor& tag, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor leaky_relu(const tensor& features, float alpha = 2.0000e-01);
    tensor leaky_relu_grad(const tensor& gradients, const tensor& features, float alpha = 2.0000e-01);
    tensor left_shift(const tensor& x, const tensor& y);
    tensor less(const tensor& x, const tensor& y);
    tensor less_equal(const tensor& x, const tensor& y);
    tensor lgamma(const tensor& x);
    tensor lin_space(const tensor& start, const tensor& stop, const tensor& num, datatype Tidx = static_cast<datatype>(3));
    tensor load_and_remap_matrix(const tensor& ckpt_path, const tensor& old_input_tensor_name, const tensor& row_remapping, const tensor& col_remapping, const tensor& initializing_values, int64_t num_rows, int64_t num_cols, int64_t max_rows_in_memory = -1);
    tensor log(const tensor& x);
    tensor log1p(const tensor& x);
    tensor log_softmax(const tensor& logits);
    tensor logical_and(const tensor& x, const tensor& y);
    tensor logical_not(const tensor& x);
    tensor logical_or(const tensor& x, const tensor& y);
    tensor lookup_table_find(const tensor& table_handle, const tensor& keys, const tensor& default_value, datatype Tin, datatype Tout);
    tensor lookup_table_find_v2(const tensor& table_handle, const tensor& keys, const tensor& default_value, datatype Tin, datatype Tout);
    tensor lookup_table_size(const tensor& table_handle);
    tensor lookup_table_size_v2(const tensor& table_handle);
    tensor loop_cond(const tensor& input);
    tensor lower_bound(const tensor& sorted_inputs, const tensor& values, datatype out_type = static_cast<datatype>(3));
    tensor map_incomplete_size(const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor map_peek(const tensor& key, const tensor& indices, const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor map_size(const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor map_unstage(const tensor& key, const tensor& indices, const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor mat_mul(const tensor& a, const tensor& b, bool transpose_a = false, bool transpose_b = false);
    tensor matching_files(const tensor& pattern);
    tensor matching_files_dataset(const tensor& patterns);
    tensor matrix_band_part(const tensor& input, const tensor& num_lower, const tensor& num_upper, datatype Tindex = static_cast<datatype>(9));
    tensor matrix_determinant(const tensor& input);
    tensor matrix_diag(const tensor& diagonal);
    tensor matrix_diag_part(const tensor& input);
    tensor matrix_diag_part_v2(const tensor& input, const tensor& k, const tensor& padding_value);
    tensor matrix_diag_part_v3(const tensor& input, const tensor& k, const tensor& padding_value, const std::string& align = "RIGHT_LEFT");
    tensor matrix_diag_v2(const tensor& diagonal, const tensor& k, const tensor& num_rows, const tensor& num_cols, const tensor& padding_value);
    tensor matrix_diag_v3(const tensor& diagonal, const tensor& k, const tensor& num_rows, const tensor& num_cols, const tensor& padding_value, const std::string& align = "RIGHT_LEFT");
    tensor matrix_exponential(const tensor& input);
    tensor matrix_inverse(const tensor& input, bool adjoint = false);
    tensor matrix_logarithm(const tensor& input);
    tensor matrix_set_diag(const tensor& input, const tensor& diagonal);
    tensor matrix_set_diag_v2(const tensor& input, const tensor& diagonal, const tensor& k);
    tensor matrix_set_diag_v3(const tensor& input, const tensor& diagonal, const tensor& k, const std::string& align = "RIGHT_LEFT");
    tensor matrix_solve(const tensor& matrix, const tensor& rhs, bool adjoint = false);
    tensor matrix_solve_ls(const tensor& matrix, const tensor& rhs, const tensor& l2_regularizer, bool fast = true);
    tensor matrix_square_root(const tensor& input);
    tensor matrix_triangular_solve(const tensor& matrix, const tensor& rhs, bool lower = true, bool adjoint = false);
    tensor max(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor max_intra_op_parallelism_dataset(const tensor& input_dataset, const tensor& max_intra_op_parallelism, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor max_pool(const tensor& input, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor max_pool3_d(const tensor& input, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NDHWC");
    tensor max_pool3_d_grad(const tensor& orig_input, const tensor& orig_output, const tensor& grad, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NDHWC", datatype TInput = static_cast<datatype>(1));
    tensor max_pool3_d_grad_grad(const tensor& orig_input, const tensor& orig_output, const tensor& grad, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NDHWC");
    tensor max_pool_grad(const tensor& orig_input, const tensor& orig_output, const tensor& grad, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor max_pool_grad_grad(const tensor& orig_input, const tensor& orig_output, const tensor& grad, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor max_pool_grad_grad_v2(const tensor& orig_input, const tensor& orig_output, const tensor& grad, const tensor& ksize, const tensor& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor max_pool_grad_grad_with_argmax(const tensor& input, const tensor& grad, const tensor& argmax, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, datatype Targmax, bool include_batch_in_index = false);
    tensor max_pool_grad_v2(const tensor& orig_input, const tensor& orig_output, const tensor& grad, const tensor& ksize, const tensor& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor max_pool_grad_with_argmax(const tensor& input, const tensor& grad, const tensor& argmax, const std::vector<int64_t>& ksize, const std::vector<int64_t>& strides, const std::string& padding, datatype Targmax, bool include_batch_in_index = false);
    tensor max_pool_v2(const tensor& input, const tensor& ksize, const tensor& strides, const std::string& padding, const std::string& data_format = "NHWC");
    tensor maximum(const tensor& x, const tensor& y);
    tensor mean(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor merge_summary(const std::vector<tensor>& inputs);
    tensor mfcc(const tensor& spectrogram, const tensor& sample_rate, float upper_frequency_limit = 4.0000e+03, float lower_frequency_limit = 2.0000e+01, int64_t filterbank_channel_count = 40, int64_t dct_coefficient_count = 13);
    tensor min(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor minimum(const tensor& x, const tensor& y);
    tensor mirror_pad(const tensor& input, const tensor& paddings, const std::string& mode, datatype Tpaddings = static_cast<datatype>(3));
    tensor mirror_pad_grad(const tensor& input, const tensor& paddings, const std::string& mode, datatype Tpaddings = static_cast<datatype>(3));
    tensor mod(const tensor& x, const tensor& y);
    tensor model_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, int64_t algorithm = 0, int64_t cpu_budget = 0);
    tensor mul(const tensor& x, const tensor& y);
    tensor mul_no_nan(const tensor& x, const tensor& y);
    tensor multi_device_iterator(const std::vector< std::string>& devices, const std::string& shared_name, const std::string& container, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor multi_device_iterator_from_string_handle(const tensor& string_handle, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor multi_device_iterator_get_next_from_shard(const tensor& multi_device_iterator, const tensor& shard_num, const tensor& incarnation_id, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor multi_device_iterator_init(const tensor& dataset, const tensor& multi_device_iterator, const tensor& max_buffer_size);
    tensor multi_device_iterator_to_string_handle(const tensor& multi_device_iterator);
    tensor multinomial(const tensor& logits, const tensor& num_samples, int64_t seed = 0, int64_t seed2 = 0, datatype output_dtype = static_cast<datatype>(9));
    tensor mutable_dense_hash_table(const tensor& empty_key, datatype key_dtype, datatype value_dtype, const std::vector<int64_t>& value_shape, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false, int64_t initial_num_buckets = 131072, float max_load_factor = 8.0000e-01);
    tensor mutable_dense_hash_table_v2(const tensor& empty_key, const tensor& deleted_key, datatype key_dtype, datatype value_dtype, const std::vector<int64_t>& value_shape, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false, int64_t initial_num_buckets = 131072, float max_load_factor = 8.0000e-01);
    tensor mutable_hash_table(datatype key_dtype, datatype value_dtype, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false);
    tensor mutable_hash_table_of_tensors(datatype key_dtype, datatype value_dtype, const std::vector<int64_t>& value_shape, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false);
    tensor mutable_hash_table_of_tensors_v2(datatype key_dtype, datatype value_dtype, const std::vector<int64_t>& value_shape, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false);
    tensor mutable_hash_table_v2(datatype key_dtype, datatype value_dtype, const std::string& container = "", const std::string& shared_name = "", bool use_node_name_sharing = false);
    tensor mutex_lock(const tensor& mutex);
    tensor mutex_v2(const std::string& container = "", const std::string& shared_name = "");
    tensor nccl_all_reduce(const tensor& input, const std::string& reduction, int64_t num_devices, const std::string& shared_name);
    tensor nccl_broadcast(const tensor& input, const std::vector<int64_t>& shape);
    tensor nccl_reduce(const std::vector<tensor>& input, const std::string& reduction);
    tensor ndtri(const tensor& x);
    tensor neg(const tensor& x);
    tensor next_after(const tensor& x1, const tensor& x2);
    tensor next_iteration(const tensor& data);
    tensor non_deterministic_ints(const tensor& shape, datatype dtype = static_cast<datatype>(9), datatype shape_dtype = static_cast<datatype>(9));
    tensor non_max_suppression(const tensor& boxes, const tensor& scores, const tensor& max_output_size, float iou_threshold = 5.0000e-01);
    tensor non_max_suppression_v2(const tensor& boxes, const tensor& scores, const tensor& max_output_size, const tensor& iou_threshold, datatype T_threshold = static_cast<datatype>(1));
    tensor non_max_suppression_v3(const tensor& boxes, const tensor& scores, const tensor& max_output_size, const tensor& iou_threshold, const tensor& score_threshold, datatype T_threshold = static_cast<datatype>(1));
    tensor non_max_suppression_with_overlaps(const tensor& overlaps, const tensor& scores, const tensor& max_output_size, const tensor& overlap_threshold, const tensor& score_threshold);
    tensor non_serializable_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor not_equal(const tensor& x, const tensor& y, bool incompatible_shape_error = true);
    tensor nth_element(const tensor& input, const tensor& n, bool reverse = false);
    tensor one_hot(const tensor& indices, const tensor& depth, const tensor& on_value, const tensor& off_value, int64_t axis = -1, datatype TI = static_cast<datatype>(9));
    tensor ones_like(const tensor& x);
    tensor optimize_dataset(const tensor& input_dataset, const tensor& optimizations, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, const std::vector< std::string>& optimization_configs);
    tensor optional_from_value(const std::vector<tensor>& components, const std::vector<datatype>& Toutput_types);
    tensor optional_get_value(const tensor& optional, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor optional_has_value(const tensor& optional);
    tensor optional_none();
    tensor ordered_map_incomplete_size(const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor ordered_map_peek(const tensor& key, const tensor& indices, const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor ordered_map_size(const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor ordered_map_unstage(const tensor& key, const tensor& indices, const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor outfeed_dequeue(datatype dtype, const std::vector<int64_t>& shape, int64_t device_ordinal = -1);
    tensor outfeed_dequeue_tuple(const std::vector<datatype>& dtypes, const std::vector< std::vector<int64_t>>& shapes, int64_t device_ordinal = -1);
    tensor pack(const std::vector<tensor>& values, int64_t axis = 0);
    tensor pad(const tensor& input, const tensor& paddings, datatype Tpaddings = static_cast<datatype>(3));
    tensor pad_v2(const tensor& input, const tensor& paddings, const tensor& constant_values, datatype Tpaddings = static_cast<datatype>(3));
    tensor padded_batch_dataset(const tensor& input_dataset, const tensor& batch_size, const std::vector<tensor>& padded_shapes, const std::vector<tensor>& padding_values, const std::vector<datatype>& Toutput_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor padded_batch_dataset_v2(const tensor& input_dataset, const tensor& batch_size, const std::vector<tensor>& padded_shapes, const std::vector<tensor>& padding_values, const tensor& drop_remainder, const std::vector<datatype>& Toutput_types, const std::vector< std::vector<int64_t>>& output_shapes, bool parallel_copy = false);
    tensor padding_f_i_f_o_queue(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor padding_f_i_f_o_queue_v2(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor parallel_concat(const std::vector<tensor>& values, const std::vector<int64_t>& shape);
    tensor parallel_dynamic_stitch(const std::vector<tensor>& indices, const std::vector<tensor>& data);
    tensor parameterized_truncated_normal(const tensor& shape, const tensor& means, const tensor& stdevs, const tensor& minvals, const tensor& maxvals, datatype dtype, int64_t seed = 0, int64_t seed2 = 0);
    tensor parse_example_dataset(const tensor& input_dataset, const tensor& num_parallel_calls, const std::vector<tensor>& dense_defaults, const std::vector< std::string>& sparse_keys, const std::vector< std::string>& dense_keys, const std::vector<datatype>& sparse_types, const std::vector<datatype>& Tdense, const std::vector< std::vector<int64_t>>& dense_shapes, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, const std::vector< std::string>& ragged_keys, const std::vector<datatype>& ragged_value_types, const std::vector<datatype>& ragged_split_types, bool sloppy = false);
    tensor parse_example_dataset_v2(const tensor& input_dataset, const tensor& num_parallel_calls, const std::vector<tensor>& dense_defaults, const std::vector< std::string>& sparse_keys, const std::vector< std::string>& dense_keys, const std::vector<datatype>& sparse_types, const std::vector<datatype>& Tdense, const std::vector< std::vector<int64_t>>& dense_shapes, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, const std::vector< std::string>& ragged_keys, const std::vector<datatype>& ragged_value_types, const std::vector<datatype>& ragged_split_types, const std::string& deterministic = "default");
    tensor parse_tensor(const tensor& serialized, datatype out_type);
    tensor placeholder(datatype dtype, const std::vector<int64_t>& shape);
    tensor placeholder_v2(datatype dtype, const std::vector<int64_t>& shape);
    tensor placeholder_with_default(const tensor& input, datatype dtype, const std::vector<int64_t>& shape);
    tensor polygamma(const tensor& a, const tensor& x);
    tensor population_count(const tensor& x);
    tensor pow(const tensor& x, const tensor& y);
    tensor prefetch_dataset(const tensor& input_dataset, const tensor& buffer_size, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, int64_t slack_period = 0, bool legacy_autotune = true);
    tensor prelinearize(const tensor& input, datatype dtype, const std::vector<int64_t>& shape, const std::vector<int64_t>& layout);
    tensor prelinearize_tuple(const std::vector<tensor>& inputs, const std::vector<datatype>& dtypes, const std::vector< std::vector<int64_t>>& shapes, const std::vector<int64_t>& layouts);
    tensor prevent_gradient(const tensor& input, const std::string& message = "");
    tensor print(const tensor& input, const std::vector<tensor>& data, const std::vector<datatype>& U, const std::string& message = "", int64_t first_n = -1, int64_t summarize = 3);
    tensor priority_queue(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor priority_queue_v2(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, const std::string& container = "", const std::string& shared_name = "");
    tensor private_thread_pool_dataset(const tensor& input_dataset, const tensor& num_threads, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor prod(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor py_func(const std::vector<tensor>& input, const std::string& token, const std::vector<datatype>& Tin, const std::vector<datatype>& Tout);
    tensor py_func_stateless(const std::vector<tensor>& input, const std::string& token, const std::vector<datatype>& Tin, const std::vector<datatype>& Tout);
    tensor quantize_and_dequantize(const tensor& input, bool signed_input = true, int64_t num_bits = 8, bool range_given = false, float input_min = 0.0000e+00, float input_max = 0.0000e+00);
    tensor quantize_and_dequantize_v2(const tensor& input, const tensor& input_min, const tensor& input_max, bool signed_input = true, int64_t num_bits = 8, bool range_given = false, const std::string& round_mode = "HALF_TO_EVEN", bool narrow_range = false, int64_t axis = -1);
    tensor quantize_and_dequantize_v3(const tensor& input, const tensor& input_min, const tensor& input_max, const tensor& num_bits, bool signed_input = true, bool range_given = true, bool narrow_range = false, int64_t axis = -1);
    tensor quantized_mat_mul_with_bias_and_dequantize(const tensor& a, const tensor& b, const tensor& bias, const tensor& min_a, const tensor& max_a, const tensor& min_b, const tensor& max_b, const tensor& min_freezed_output, const tensor& max_freezed_output, datatype T1, datatype T2, datatype Tbias, datatype Toutput, bool transpose_a = false, bool transpose_b = false, const std::string& input_quant_mode = "MIN_FIRST");
    tensor queue_dequeue(const tensor& handle, const std::vector<datatype>& component_types, int64_t timeout_ms = -1);
    tensor queue_dequeue_many(const tensor& handle, const tensor& n, const std::vector<datatype>& component_types, int64_t timeout_ms = -1);
    tensor queue_dequeue_many_v2(const tensor& handle, const tensor& n, const std::vector<datatype>& component_types, int64_t timeout_ms = -1);
    tensor queue_dequeue_up_to(const tensor& handle, const tensor& n, const std::vector<datatype>& component_types, int64_t timeout_ms = -1);
    tensor queue_dequeue_up_to_v2(const tensor& handle, const tensor& n, const std::vector<datatype>& component_types, int64_t timeout_ms = -1);
    tensor queue_dequeue_v2(const tensor& handle, const std::vector<datatype>& component_types, int64_t timeout_ms = -1);
    tensor queue_is_closed(const tensor& handle);
    tensor queue_is_closed_v2(const tensor& handle);
    tensor queue_size(const tensor& handle);
    tensor queue_size_v2(const tensor& handle);
    tensor r_f_f_t(const tensor& input, const tensor& fft_length, datatype Treal = static_cast<datatype>(1), datatype Tcomplex = static_cast<datatype>(8));
    tensor r_f_f_t2_d(const tensor& input, const tensor& fft_length, datatype Treal = static_cast<datatype>(1), datatype Tcomplex = static_cast<datatype>(8));
    tensor r_f_f_t3_d(const tensor& input, const tensor& fft_length, datatype Treal = static_cast<datatype>(1), datatype Tcomplex = static_cast<datatype>(8));
    tensor r_g_b_to_h_s_v(const tensor& images);
    tensor ragged_tensor_to_tensor(const tensor& shape, const tensor& values, const tensor& default_value, const std::vector<tensor>& row_partition_tensors, datatype Tindex, datatype Tshape, const std::vector< std::string>& row_partition_types);
    tensor ragged_tensor_to_variant(const std::vector<tensor>& rt_nested_splits, const tensor& rt_dense_values, datatype Tvalues, bool batched_input, datatype Tsplits = static_cast<datatype>(9));
    tensor random_crop(const tensor& image, const tensor& size, int64_t seed = 0, int64_t seed2 = 0);
    tensor random_dataset(const tensor& seed, const tensor& seed2, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor random_gamma(const tensor& shape, const tensor& alpha, datatype S, int64_t seed = 0, int64_t seed2 = 0);
    tensor random_gamma_grad(const tensor& alpha, const tensor& sample);
    tensor random_poisson(const tensor& shape, const tensor& rate, datatype S, datatype dtype, int64_t seed = 0, int64_t seed2 = 0);
    tensor random_poisson_v2(const tensor& shape, const tensor& rate, datatype S, int64_t seed = 0, int64_t seed2 = 0, datatype R = static_cast<datatype>(2), datatype dtype = static_cast<datatype>(9));
    tensor random_shuffle(const tensor& value, int64_t seed = 0, int64_t seed2 = 0);
    tensor random_shuffle_queue(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, int64_t min_after_dequeue = 0, int64_t seed = 0, int64_t seed2 = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor random_shuffle_queue_v2(const std::vector<datatype>& component_types, const std::vector< std::vector<int64_t>>& shapes, int64_t capacity = -1, int64_t min_after_dequeue = 0, int64_t seed = 0, int64_t seed2 = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor random_standard_normal(const tensor& shape, datatype dtype, int64_t seed = 0, int64_t seed2 = 0);
    tensor random_uniform(const tensor& shape, datatype dtype, int64_t seed = 0, int64_t seed2 = 0);
    tensor random_uniform_int(const tensor& shape, const tensor& minval, const tensor& maxval, datatype Tout, int64_t seed = 0, int64_t seed2 = 0);
    tensor range(const tensor& start, const tensor& limit, const tensor& delta, datatype Tidx = static_cast<datatype>(3));
    tensor range_dataset(const tensor& start, const tensor& stop, const tensor& step, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor rank(const tensor& input);
    tensor read_file(const tensor& filename);
    tensor read_variable_op(const tensor& resource, datatype dtype);
    tensor reader_num_records_produced(const tensor& reader_handle);
    tensor reader_num_records_produced_v2(const tensor& reader_handle);
    tensor reader_num_work_units_completed(const tensor& reader_handle);
    tensor reader_num_work_units_completed_v2(const tensor& reader_handle);
    tensor reader_serialize_state(const tensor& reader_handle);
    tensor reader_serialize_state_v2(const tensor& reader_handle);
    tensor real(const tensor& input, datatype Tout = static_cast<datatype>(1));
    tensor real_div(const tensor& x, const tensor& y);
    tensor rebatch_dataset(const tensor& input_dataset, const tensor& num_replicas, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool use_fallback = true);
    tensor reciprocal(const tensor& x);
    tensor reciprocal_grad(const tensor& y, const tensor& dy);
    tensor record_input(const std::string& file_pattern, int64_t file_random_seed = 301, float file_shuffle_shift_ratio = 0.0000e+00, int64_t file_buffer_size = 10000, int64_t file_parallelism = 16, int64_t batch_size = 32, const std::string& compression_type = "");
    tensor recv(datatype tensor_type, const std::string& tensor_name, const std::string& send_device, int64_t send_device_incarnation, const std::string& recv_device, bool client_terminated = false);
    tensor recv_t_p_u_embedding_activations(int64_t num_outputs, const std::string& config);
    tensor reduce_join(const tensor& inputs, const tensor& reduction_indices, bool keep_dims = false, const std::string& separator = "");
    tensor ref_enter(const tensor& data, const std::string& frame_name, bool is_constant = false, int64_t parallel_iterations = 10);
    tensor ref_exit(const tensor& data);
    tensor ref_identity(const tensor& input);
    tensor ref_next_iteration(const tensor& data);
    tensor ref_select(const tensor& index, const std::vector<tensor>& inputs);
    tensor regex_full_match(const tensor& input, const tensor& pattern);
    tensor regex_replace(const tensor& input, const tensor& pattern, const tensor& rewrite, bool replace_global = true);
    tensor relu(const tensor& features);
    tensor relu6(const tensor& features);
    tensor relu6_grad(const tensor& gradients, const tensor& features);
    tensor relu_grad(const tensor& gradients, const tensor& features);
    tensor repeat_dataset(const tensor& input_dataset, const tensor& count, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor reshape(const tensor& input_tensor, const tensor& shape, datatype Tshape = static_cast<datatype>(3));
    tensor resize_area(const tensor& images, const tensor& size, bool align_corners = false);
    tensor resize_bicubic(const tensor& images, const tensor& size, bool align_corners = false, bool half_pixel_centers = false);
    tensor resize_bicubic_grad(const tensor& grads, const tensor& original_image, bool align_corners = false, bool half_pixel_centers = false);
    tensor resize_bilinear(const tensor& images, const tensor& size, bool align_corners = false, bool half_pixel_centers = false);
    tensor resize_bilinear_grad(const tensor& grads, const tensor& original_image, bool align_corners = false, bool half_pixel_centers = false);
    tensor resize_nearest_neighbor(const tensor& images, const tensor& size, bool align_corners = false, bool half_pixel_centers = false);
    tensor resize_nearest_neighbor_grad(const tensor& grads, const tensor& size, bool align_corners = false, bool half_pixel_centers = false);
    tensor resource_accumulator_num_accumulated(const tensor& handle);
    tensor resource_accumulator_take_gradient(const tensor& handle, const tensor& num_required, datatype dtype);
    tensor resource_conditional_accumulator(datatype dtype, const std::vector<int64_t>& shape, const std::string& container = "", const std::string& shared_name = "", const std::string& reduction_type = "MEAN");
    tensor resource_count_up_to(const tensor& resource, int64_t limit);
    tensor resource_gather(const tensor& resource, const tensor& indices, datatype dtype, datatype Tindices, int64_t batch_dims = 0, bool validate_indices = true);
    tensor resource_gather_nd(const tensor& resource, const tensor& indices, datatype dtype, datatype Tindices);
    tensor restore(const tensor& file_pattern, const tensor& input_tensor_name, datatype dt, int64_t preferred_shard = -1);
    tensor restore_slice(const tensor& file_pattern, const tensor& input_tensor_name, const tensor& shape_and_slice, datatype dt, int64_t preferred_shard = -1);
    tensor restore_v2(const tensor& prefix, const tensor& input_tensor_names, const tensor& shape_and_slices, const std::vector<datatype>& dtypes);
    tensor retrieve_t_p_u_embedding_stochastic_gradient_descent_parameters(int64_t num_shards, int64_t shard_id, int64_t table_id = -1, const std::string& table_name = "", const std::string& config = "");
    tensor reverse(const tensor& input_tensor, const tensor& dims);
    tensor reverse_sequence(const tensor& input, const tensor& seq_lengths, int64_t seq_dim, int64_t batch_dim = 0, datatype Tlen = static_cast<datatype>(9));
    tensor reverse_v2(const tensor& input_tensor, const tensor& axis, datatype Tidx = static_cast<datatype>(3));
    tensor right_shift(const tensor& x, const tensor& y);
    tensor rint(const tensor& x);
    tensor roll(const tensor& input, const tensor& shift, const tensor& axis, datatype Tshift, datatype Taxis);
    tensor round(const tensor& x);
    tensor rsqrt(const tensor& x);
    tensor rsqrt_grad(const tensor& y, const tensor& dy);
    tensor sampling_dataset(const tensor& input_dataset, const tensor& rate, const tensor& seed, const tensor& seed2, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor scalar_summary(const tensor& tags, const tensor& values);
    tensor scale_and_translate(const tensor& images, const tensor& size, const tensor& scale, const tensor& translation, const std::string& kernel_type = "lanczos3", bool antialias = true);
    tensor scale_and_translate_grad(const tensor& grads, const tensor& original_image, const tensor& scale, const tensor& translation, const std::string& kernel_type = "lanczos3", bool antialias = true);
    tensor scatter_add(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_div(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_max(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_min(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_mul(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_nd(const tensor& indices, const tensor& updates, const tensor& shape, datatype Tindices);
    tensor scatter_nd_add(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_nd_non_aliasing_add(const tensor& input, const tensor& indices, const tensor& updates, datatype Tindices);
    tensor scatter_nd_sub(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_nd_update(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = true);
    tensor scatter_sub(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = false);
    tensor scatter_update(const tensor& ref, const tensor& indices, const tensor& updates, datatype Tindices, bool use_locking = true);
    tensor sdca_fprint(const tensor& input);
    tensor segment_max(const tensor& data, const tensor& segment_ids, datatype Tindices);
    tensor segment_mean(const tensor& data, const tensor& segment_ids, datatype Tindices);
    tensor segment_min(const tensor& data, const tensor& segment_ids, datatype Tindices);
    tensor segment_prod(const tensor& data, const tensor& segment_ids, datatype Tindices);
    tensor segment_sum(const tensor& data, const tensor& segment_ids, datatype Tindices);
    tensor select(const tensor& condition, const tensor& t, const tensor& e);
    tensor select_v2(const tensor& condition, const tensor& t, const tensor& e);
    tensor self_adjoint_eig(const tensor& input);
    tensor selu(const tensor& features);
    tensor selu_grad(const tensor& gradients, const tensor& outputs);
    tensor serialize_iterator(const tensor& resource_handle, int64_t external_state_policy = 0);
    tensor serialize_many_sparse(const tensor& sparse_indices, const tensor& sparse_values, const tensor& sparse_shape, datatype out_type = static_cast<datatype>(7));
    tensor serialize_sparse(const tensor& sparse_indices, const tensor& sparse_values, const tensor& sparse_shape, datatype out_type = static_cast<datatype>(7));
    tensor serialize_tensor(const tensor& input_tensor);
    tensor set_size(const tensor& set_indices, const tensor& set_values, const tensor& set_shape, bool validate_indices = true);
    tensor set_stats_aggregator_dataset(const tensor& input_dataset, const tensor& stats_aggregator, const tensor& tag, const tensor& counter_prefix, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor shape(const tensor& input, datatype out_type = static_cast<datatype>(3));
    tensor shape_n(const std::vector<tensor>& input, datatype out_type = static_cast<datatype>(3));
    tensor shard_dataset(const tensor& input_dataset, const tensor& num_shards, const tensor& index, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool require_non_empty = false);
    tensor sharded_filename(const tensor& basename, const tensor& shard, const tensor& num_shards);
    tensor sharded_filespec(const tensor& basename, const tensor& num_shards);
    tensor shuffle_and_repeat_dataset(const tensor& input_dataset, const tensor& buffer_size, const tensor& seed, const tensor& seed2, const tensor& count, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool reshuffle_each_iteration = true);
    tensor shuffle_dataset(const tensor& input_dataset, const tensor& buffer_size, const tensor& seed, const tensor& seed2, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, bool reshuffle_each_iteration = true);
    tensor shuffle_dataset_v2(const tensor& input_dataset, const tensor& buffer_size, const tensor& seed_generator, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor sigmoid(const tensor& x);
    tensor sigmoid_grad(const tensor& y, const tensor& dy);
    tensor sign(const tensor& x);
    tensor sin(const tensor& x);
    tensor sinh(const tensor& x);
    tensor size(const tensor& input, datatype out_type = static_cast<datatype>(3));
    tensor skip_dataset(const tensor& input_dataset, const tensor& count, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor sleep_dataset(const tensor& input_dataset, const tensor& sleep_microseconds, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor slice(const tensor& input, const tensor& begin, const tensor& size, datatype Index);
    tensor sliding_window_dataset(const tensor& input_dataset, const tensor& window_size, const tensor& window_shift, const tensor& window_stride, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor snapshot(const tensor& input);
    tensor snapshot_dataset(const tensor& input_dataset, const tensor& path, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes, const std::string& compression = "", const std::string& reader_path_prefix = "", const std::string& writer_path_prefix = "", int64_t shard_size_bytes = 10737418240, int64_t pending_snapshot_expiry_seconds = 86400, int64_t num_reader_threads = 1, int64_t reader_buffer_size = 1, int64_t num_writer_threads = 1, int64_t writer_buffer_size = 1, bool shuffle_on_read = false, int64_t seed = 0, int64_t seed2 = 0, const std::string& mode = "auto", const std::string& snapshot_name = "");
    tensor sobol_sample(const tensor& dim, const tensor& num_results, const tensor& skip, datatype dtype = static_cast<datatype>(1));
    tensor softmax(const tensor& logits);
    tensor softplus(const tensor& features);
    tensor softplus_grad(const tensor& gradients, const tensor& features);
    tensor softsign(const tensor& features);
    tensor softsign_grad(const tensor& gradients, const tensor& features);
    tensor space_to_batch(const tensor& input, const tensor& paddings, int64_t block_size, datatype Tpaddings = static_cast<datatype>(3));
    tensor space_to_batch_n_d(const tensor& input, const tensor& block_shape, const tensor& paddings, datatype Tblock_shape = static_cast<datatype>(3), datatype Tpaddings = static_cast<datatype>(3));
    tensor space_to_depth(const tensor& input, int64_t block_size, const std::string& data_format = "NHWC");
    tensor sparse_apply_adadelta(const tensor& var, const tensor& accum, const tensor& accum_update, const tensor& lr, const tensor& rho, const tensor& epsilon, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false);
    tensor sparse_apply_adagrad(const tensor& var, const tensor& accum, const tensor& lr, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false, bool update_slots = true);
    tensor sparse_apply_adagrad_d_a(const tensor& var, const tensor& gradient_accumulator, const tensor& gradient_squared_accumulator, const tensor& grad, const tensor& indices, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& global_step, datatype Tindices, bool use_locking = false);
    tensor sparse_apply_adagrad_v2(const tensor& var, const tensor& accum, const tensor& lr, const tensor& epsilon, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false, bool update_slots = true);
    tensor sparse_apply_centered_r_m_s_prop(const tensor& var, const tensor& mg, const tensor& ms, const tensor& mom, const tensor& lr, const tensor& rho, const tensor& momentum, const tensor& epsilon, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false);
    tensor sparse_apply_ftrl(const tensor& var, const tensor& accum, const tensor& linear, const tensor& grad, const tensor& indices, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& lr_power, datatype Tindices, bool use_locking = false, bool multiply_linear_by_lr = false);
    tensor sparse_apply_ftrl_v2(const tensor& var, const tensor& accum, const tensor& linear, const tensor& grad, const tensor& indices, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& l2_shrinkage, const tensor& lr_power, datatype Tindices, bool use_locking = false, bool multiply_linear_by_lr = false);
    tensor sparse_apply_momentum(const tensor& var, const tensor& accum, const tensor& lr, const tensor& grad, const tensor& indices, const tensor& momentum, datatype Tindices, bool use_locking = false, bool use_nesterov = false);
    tensor sparse_apply_proximal_adagrad(const tensor& var, const tensor& accum, const tensor& lr, const tensor& l1, const tensor& l2, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false);
    tensor sparse_apply_proximal_gradient_descent(const tensor& var, const tensor& alpha, const tensor& l1, const tensor& l2, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false);
    tensor sparse_apply_r_m_s_prop(const tensor& var, const tensor& ms, const tensor& mom, const tensor& lr, const tensor& rho, const tensor& momentum, const tensor& epsilon, const tensor& grad, const tensor& indices, datatype Tindices, bool use_locking = false);
    tensor sparse_conditional_accumulator(datatype dtype, const std::vector<int64_t>& shape, const std::string& container = "", const std::string& shared_name = "", const std::string& reduction_type = "MEAN");
    tensor sparse_dense_cwise_add(const tensor& sp_indices, const tensor& sp_values, const tensor& sp_shape, const tensor& dense);
    tensor sparse_dense_cwise_div(const tensor& sp_indices, const tensor& sp_values, const tensor& sp_shape, const tensor& dense);
    tensor sparse_dense_cwise_mul(const tensor& sp_indices, const tensor& sp_values, const tensor& sp_shape, const tensor& dense);
    tensor sparse_mat_mul(const tensor& a, const tensor& b, bool transpose_a = false, bool transpose_b = false, bool a_is_sparse = false, bool b_is_sparse = false, datatype Ta = static_cast<datatype>(1), datatype Tb = static_cast<datatype>(1));
    tensor sparse_matrix_add(const tensor& a, const tensor& b, const tensor& alpha, const tensor& beta);
    tensor sparse_matrix_mat_mul(const tensor& a, const tensor& b, bool transpose_a = false, bool transpose_b = false, bool adjoint_a = false, bool adjoint_b = false, bool transpose_output = false, bool conjugate_output = false);
    tensor sparse_matrix_mul(const tensor& a, const tensor& b);
    tensor sparse_matrix_n_n_z(const tensor& sparse_matrix);
    tensor sparse_matrix_ordering_a_m_d(const tensor& input);
    tensor sparse_matrix_softmax(const tensor& logits, datatype type);
    tensor sparse_matrix_softmax_grad(const tensor& softmax, const tensor& grad_softmax, datatype type);
    tensor sparse_matrix_sparse_cholesky(const tensor& input, const tensor& permutation, datatype type);
    tensor sparse_matrix_sparse_mat_mul(const tensor& a, const tensor& b, datatype type, bool transpose_a = false, bool transpose_b = false, bool adjoint_a = false, bool adjoint_b = false);
    tensor sparse_matrix_transpose(const tensor& input, datatype type, bool conjugate = false);
    tensor sparse_matrix_zeros(const tensor& dense_shape, datatype type);
    tensor sparse_reduce_max(const tensor& input_indices, const tensor& input_values, const tensor& input_shape, const tensor& reduction_axes, bool keep_dims = false);
    tensor sparse_reduce_sum(const tensor& input_indices, const tensor& input_values, const tensor& input_shape, const tensor& reduction_axes, bool keep_dims = false);
    tensor sparse_segment_mean(const tensor& data, const tensor& indices, const tensor& segment_ids, datatype Tidx = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_mean_grad(const tensor& grad, const tensor& indices, const tensor& segment_ids, const tensor& output_dim0, datatype Tidx = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_mean_with_num_segments(const tensor& data, const tensor& indices, const tensor& segment_ids, const tensor& num_segments, datatype Tidx = static_cast<datatype>(3), datatype Tnumsegments = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_sqrt_n(const tensor& data, const tensor& indices, const tensor& segment_ids, datatype Tidx = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_sqrt_n_grad(const tensor& grad, const tensor& indices, const tensor& segment_ids, const tensor& output_dim0, datatype Tidx = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_sqrt_n_with_num_segments(const tensor& data, const tensor& indices, const tensor& segment_ids, const tensor& num_segments, datatype Tidx = static_cast<datatype>(3), datatype Tnumsegments = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_sum(const tensor& data, const tensor& indices, const tensor& segment_ids, datatype Tidx = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_segment_sum_with_num_segments(const tensor& data, const tensor& indices, const tensor& segment_ids, const tensor& num_segments, datatype Tidx = static_cast<datatype>(3), datatype Tnumsegments = static_cast<datatype>(3), datatype Tsegmentids = static_cast<datatype>(3));
    tensor sparse_slice_grad(const tensor& backprop_val_grad, const tensor& input_indices, const tensor& input_start, const tensor& output_indices);
    tensor sparse_softmax(const tensor& sp_indices, const tensor& sp_values, const tensor& sp_shape);
    tensor sparse_tensor_dense_add(const tensor& a_indices, const tensor& a_values, const tensor& a_shape, const tensor& b, datatype Tindices);
    tensor sparse_tensor_dense_mat_mul(const tensor& a_indices, const tensor& a_values, const tensor& a_shape, const tensor& b, datatype Tindices = static_cast<datatype>(9), bool adjoint_a = false, bool adjoint_b = false);
    tensor sparse_tensor_slice_dataset(const tensor& indices, const tensor& values, const tensor& dense_shape, datatype Tvalues);
    tensor sparse_tensor_to_c_s_r_sparse_matrix(const tensor& indices, const tensor& values, const tensor& dense_shape);
    tensor sparse_to_dense(const tensor& sparse_indices, const tensor& output_shape, const tensor& sparse_values, const tensor& default_value, datatype Tindices, bool validate_indices = true);
    tensor spence(const tensor& x);
    tensor split(const tensor& split_dim, const tensor& value, int64_t num_split);
    tensor split_v(const tensor& value, const tensor& size_splits, const tensor& split_dim, int64_t num_split, datatype Tlen = static_cast<datatype>(9));
    tensor sql_dataset(const tensor& driver_name, const tensor& data_source_name, const tensor& query, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor sqrt(const tensor& x);
    tensor sqrt_grad(const tensor& y, const tensor& dy);
    tensor square(const tensor& x);
    tensor squared_difference(const tensor& x, const tensor& y);
    tensor squeeze(const tensor& input, const std::vector<int64_t>& squeeze_dims);
    tensor stack(datatype elem_type, const std::string& stack_name = "");
    tensor stack_pop(const tensor& handle, datatype elem_type);
    tensor stack_pop_v2(const tensor& handle, datatype elem_type);
    tensor stack_push(const tensor& handle, const tensor& elem, bool swap_memory = false);
    tensor stack_push_v2(const tensor& handle, const tensor& elem, bool swap_memory = false);
    tensor stack_v2(const tensor& max_size, datatype elem_type, const std::string& stack_name = "");
    tensor stage_peek(const tensor& index, const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor stage_size(const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor stateful_random_binomial(const tensor& resource, const tensor& algorithm, const tensor& shape, const tensor& counts, const tensor& probs, datatype S, datatype dtype = static_cast<datatype>(9));
    tensor stateful_standard_normal(const tensor& resource, const tensor& shape, datatype dtype = static_cast<datatype>(1), datatype shape_dtype = static_cast<datatype>(9));
    tensor stateful_standard_normal_v2(const tensor& resource, const tensor& algorithm, const tensor& shape, datatype dtype = static_cast<datatype>(1), datatype shape_dtype = static_cast<datatype>(9));
    tensor stateful_truncated_normal(const tensor& resource, const tensor& algorithm, const tensor& shape, datatype dtype = static_cast<datatype>(1), datatype shape_dtype = static_cast<datatype>(9));
    tensor stateful_uniform(const tensor& resource, const tensor& algorithm, const tensor& shape, datatype dtype = static_cast<datatype>(1), datatype shape_dtype = static_cast<datatype>(9));
    tensor stateful_uniform_full_int(const tensor& resource, const tensor& algorithm, const tensor& shape, datatype dtype = static_cast<datatype>(23), datatype shape_dtype = static_cast<datatype>(9));
    tensor stateful_uniform_int(const tensor& resource, const tensor& algorithm, const tensor& shape, const tensor& minval, const tensor& maxval, datatype dtype = static_cast<datatype>(9), datatype shape_dtype = static_cast<datatype>(9));
    tensor stateless_multinomial(const tensor& logits, const tensor& num_samples, const tensor& seed, datatype Tseed = static_cast<datatype>(9), datatype output_dtype = static_cast<datatype>(9));
    tensor stateless_random_binomial(const tensor& shape, const tensor& seed, const tensor& counts, const tensor& probs, datatype S, datatype Tseed = static_cast<datatype>(9), datatype dtype = static_cast<datatype>(9));
    tensor stateless_random_gamma_v2(const tensor& shape, const tensor& seed, const tensor& alpha, datatype dtype, datatype Tseed = static_cast<datatype>(9));
    tensor stateless_random_normal(const tensor& shape, const tensor& seed, datatype dtype = static_cast<datatype>(1), datatype Tseed = static_cast<datatype>(9));
    tensor stateless_random_poisson(const tensor& shape, const tensor& seed, const tensor& lam, datatype Rtype, datatype dtype, datatype Tseed = static_cast<datatype>(9));
    tensor stateless_random_uniform(const tensor& shape, const tensor& seed, datatype dtype = static_cast<datatype>(1), datatype Tseed = static_cast<datatype>(9));
    tensor stateless_random_uniform_full_int(const tensor& shape, const tensor& seed, datatype dtype = static_cast<datatype>(23), datatype Tseed = static_cast<datatype>(9));
    tensor stateless_random_uniform_int(const tensor& shape, const tensor& seed, const tensor& minval, const tensor& maxval, datatype dtype, datatype Tseed = static_cast<datatype>(9));
    tensor stateless_truncated_normal(const tensor& shape, const tensor& seed, datatype dtype = static_cast<datatype>(1), datatype Tseed = static_cast<datatype>(9));
    tensor static_regex_full_match(const tensor& input, const std::string& pattern);
    tensor static_regex_replace(const tensor& input, const std::string& pattern, const std::string& rewrite, bool replace_global = true);
    tensor stats_aggregator_handle(const std::string& container = "", const std::string& shared_name = "");
    tensor stats_aggregator_handle_v2(const std::string& container = "", const std::string& shared_name = "");
    tensor stats_aggregator_summary(const tensor& iterator);
    tensor stop_gradient(const tensor& input);
    tensor strided_slice(const tensor& input, const tensor& begin, const tensor& end, const tensor& strides, datatype Index, int64_t begin_mask = 0, int64_t end_mask = 0, int64_t ellipsis_mask = 0, int64_t new_axis_mask = 0, int64_t shrink_axis_mask = 0);
    tensor strided_slice_assign(const tensor& ref, const tensor& begin, const tensor& end, const tensor& strides, const tensor& value, datatype Index, int64_t begin_mask = 0, int64_t end_mask = 0, int64_t ellipsis_mask = 0, int64_t new_axis_mask = 0, int64_t shrink_axis_mask = 0);
    tensor strided_slice_grad(const tensor& shape, const tensor& begin, const tensor& end, const tensor& strides, const tensor& dy, datatype Index, int64_t begin_mask = 0, int64_t end_mask = 0, int64_t ellipsis_mask = 0, int64_t new_axis_mask = 0, int64_t shrink_axis_mask = 0);
    tensor string_format(const std::vector<tensor>& inputs, const std::string& template_arg = "%s", const std::string& placeholder = "%s", int64_t summarize = 3);
    tensor string_join(const std::vector<tensor>& inputs, const std::string& separator = "");
    tensor string_length(const tensor& input, const std::string& unit = "BYTE");
    tensor string_lower(const tensor& input, const std::string& encoding = "");
    tensor string_strip(const tensor& input);
    tensor string_to_hash_bucket(const tensor& string_input_tensor, int64_t num_buckets);
    tensor string_to_hash_bucket_fast(const tensor& input, int64_t num_buckets);
    tensor string_to_hash_bucket_strong(const tensor& input, int64_t num_buckets, const std::vector<int64_t>& key);
    tensor string_to_number(const tensor& string_input_tensor, datatype out_type = static_cast<datatype>(1));
    tensor string_upper(const tensor& input, const std::string& encoding = "");
    tensor sub(const tensor& x, const tensor& y);
    tensor substr(const tensor& input, const tensor& pos, const tensor& len, const std::string& unit = "BYTE");
    tensor sum(const tensor& input, const tensor& reduction_indices, bool keep_dims = false, datatype Tidx = static_cast<datatype>(3));
    tensor summary_writer(const std::string& shared_name = "", const std::string& container = "");
    tensor t_f_record_dataset(const tensor& filenames, const tensor& compression_type, const tensor& buffer_size);
    tensor t_f_record_reader(const std::string& container = "", const std::string& shared_name = "", const std::string& compression_type = "");
    tensor t_f_record_reader_v2(const std::string& container = "", const std::string& shared_name = "", const std::string& compression_type = "");
    tensor t_p_u_compilation_result();
    tensor t_p_u_embedding_activations(const tensor& embedding_variable, const tensor& sliced_activations, int64_t table_id, int64_t lookup_id);
    tensor t_p_u_ordinal_selector();
    tensor t_p_u_replicated_input(const std::vector<tensor>& inputs, bool is_mirrored_variable = false, int64_t index = -1, bool is_packed = false);
    tensor t_p_u_replicated_output(const tensor& input, int64_t num_replicas);
    tensor take_dataset(const tensor& input_dataset, const tensor& count, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor tan(const tensor& x);
    tensor tanh(const tensor& x);
    tensor tanh_grad(const tensor& y, const tensor& dy);
    tensor temporary_variable(const std::vector<int64_t>& shape, datatype dtype, const std::string& var_name = "");
    tensor tensor_array(const tensor& size, datatype dtype, const std::vector<int64_t>& element_shape, bool dynamic_size = false, bool clear_after_read = true, const std::string& tensor_array_name = "");
    tensor tensor_array_gather(const tensor& handle, const tensor& indices, const tensor& flow_in, datatype dtype, const std::vector<int64_t>& element_shape);
    tensor tensor_array_gather_v2(const tensor& handle, const tensor& indices, const tensor& flow_in, datatype dtype, const std::vector<int64_t>& element_shape);
    tensor tensor_array_gather_v3(const tensor& handle, const tensor& indices, const tensor& flow_in, datatype dtype, const std::vector<int64_t>& element_shape);
    tensor tensor_array_grad(const tensor& handle, const tensor& flow_in, const std::string& source);
    tensor tensor_array_grad_v2(const tensor& handle, const tensor& flow_in, const std::string& source);
    tensor tensor_array_pack(const tensor& handle, const tensor& flow_in, datatype dtype, const std::vector<int64_t>& element_shape);
    tensor tensor_array_read(const tensor& handle, const tensor& index, const tensor& flow_in, datatype dtype);
    tensor tensor_array_read_v2(const tensor& handle, const tensor& index, const tensor& flow_in, datatype dtype);
    tensor tensor_array_read_v3(const tensor& handle, const tensor& index, const tensor& flow_in, datatype dtype);
    tensor tensor_array_scatter(const tensor& handle, const tensor& indices, const tensor& value, const tensor& flow_in);
    tensor tensor_array_scatter_v2(const tensor& handle, const tensor& indices, const tensor& value, const tensor& flow_in);
    tensor tensor_array_scatter_v3(const tensor& handle, const tensor& indices, const tensor& value, const tensor& flow_in);
    tensor tensor_array_size(const tensor& handle, const tensor& flow_in);
    tensor tensor_array_size_v2(const tensor& handle, const tensor& flow_in);
    tensor tensor_array_size_v3(const tensor& handle, const tensor& flow_in);
    tensor tensor_array_split(const tensor& handle, const tensor& value, const tensor& lengths, const tensor& flow_in);
    tensor tensor_array_split_v2(const tensor& handle, const tensor& value, const tensor& lengths, const tensor& flow_in);
    tensor tensor_array_split_v3(const tensor& handle, const tensor& value, const tensor& lengths, const tensor& flow_in);
    tensor tensor_array_unpack(const tensor& handle, const tensor& value, const tensor& flow_in);
    tensor tensor_array_v2(const tensor& size, datatype dtype, const std::vector<int64_t>& element_shape, bool dynamic_size = false, bool clear_after_read = true, const std::string& tensor_array_name = "");
    tensor tensor_array_write(const tensor& handle, const tensor& index, const tensor& value, const tensor& flow_in);
    tensor tensor_array_write_v2(const tensor& handle, const tensor& index, const tensor& value, const tensor& flow_in);
    tensor tensor_array_write_v3(const tensor& handle, const tensor& index, const tensor& value, const tensor& flow_in);
    tensor tensor_dataset(const std::vector<tensor>& components, const std::vector<datatype>& Toutput_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor tensor_list_concat_lists(const tensor& input_a, const tensor& input_b, datatype element_dtype);
    tensor tensor_list_element_shape(const tensor& input_handle, datatype shape_type);
    tensor tensor_list_from_tensor(const tensor& input_tensor, const tensor& element_shape, datatype element_dtype, datatype shape_type);
    tensor tensor_list_gather(const tensor& input_handle, const tensor& indices, const tensor& element_shape, datatype element_dtype);
    tensor tensor_list_get_item(const tensor& input_handle, const tensor& index, const tensor& element_shape, datatype element_dtype);
    tensor tensor_list_length(const tensor& input_handle);
    tensor tensor_list_push_back(const tensor& input_handle, const tensor& input_tensor, datatype element_dtype);
    tensor tensor_list_push_back_batch(const tensor& input_handles, const tensor& input_tensor, datatype element_dtype);
    tensor tensor_list_reserve(const tensor& element_shape, const tensor& num_elements, datatype element_dtype, datatype shape_type);
    tensor tensor_list_resize(const tensor& input_handle, const tensor& size);
    tensor tensor_list_scatter(const tensor& input_tensor, const tensor& indices, const tensor& element_shape, datatype element_dtype, datatype shape_type);
    tensor tensor_list_scatter_into_existing_list(const tensor& input_handle, const tensor& input_tensor, const tensor& indices, datatype element_dtype);
    tensor tensor_list_scatter_v2(const tensor& input_tensor, const tensor& indices, const tensor& element_shape, const tensor& num_elements, datatype element_dtype, datatype shape_type);
    tensor tensor_list_set_item(const tensor& input_handle, const tensor& index, const tensor& item, datatype element_dtype);
    tensor tensor_list_split(const tensor& input_tensor, const tensor& element_shape, const tensor& lengths, datatype element_dtype, datatype shape_type);
    tensor tensor_list_stack(const tensor& input_handle, const tensor& element_shape, datatype element_dtype, int64_t num_elements = -1);
    tensor tensor_scatter_add(const tensor& input_tensor, const tensor& indices, const tensor& updates, datatype Tindices);
    tensor tensor_scatter_sub(const tensor& input_tensor, const tensor& indices, const tensor& updates, datatype Tindices);
    tensor tensor_scatter_update(const tensor& input_tensor, const tensor& indices, const tensor& updates, datatype Tindices);
    tensor tensor_slice_dataset(const std::vector<tensor>& components, const std::vector<datatype>& Toutput_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor tensor_strided_slice_update(const tensor& input, const tensor& begin, const tensor& end, const tensor& strides, const tensor& value, datatype Index, int64_t begin_mask = 0, int64_t end_mask = 0, int64_t ellipsis_mask = 0, int64_t new_axis_mask = 0, int64_t shrink_axis_mask = 0);
    tensor tensor_summary(const tensor& input_tensor, const std::vector< std::string>& labels, const std::string& description = "", const std::string& display_name = "");
    tensor tensor_summary_v2(const tensor& tag, const tensor& input_tensor, const tensor& serialized_summary_metadata);
    tensor text_line_dataset(const tensor& filenames, const tensor& compression_type, const tensor& buffer_size);
    tensor text_line_reader(int64_t skip_header_lines = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor text_line_reader_v2(int64_t skip_header_lines = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor thread_pool_dataset(const tensor& input_dataset, const tensor& thread_pool, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor thread_pool_handle(int64_t num_threads, const std::string& display_name, int64_t max_intra_op_parallelism = 1, const std::string& container = "", const std::string& shared_name = "");
    tensor tile(const tensor& input, const tensor& multiples, datatype Tmultiples = static_cast<datatype>(3));
    tensor tile_grad(const tensor& input, const tensor& multiples);
    tensor timestamp();
    tensor to_bool(const tensor& input);
    tensor transpose(const tensor& x, const tensor& perm, datatype Tperm = static_cast<datatype>(3));
    tensor tridiagonal_mat_mul(const tensor& superdiag, const tensor& maindiag, const tensor& subdiag, const tensor& rhs);
    tensor tridiagonal_solve(const tensor& diagonals, const tensor& rhs, bool partial_pivoting = true);
    tensor truncate_div(const tensor& x, const tensor& y);
    tensor truncate_mod(const tensor& x, const tensor& y);
    tensor truncated_normal(const tensor& shape, datatype dtype, int64_t seed = 0, int64_t seed2 = 0);
    tensor unbatch(const tensor& batched_input_tensor, const tensor& batch_index, const tensor& id, int64_t timeout_micros, const std::string& container = "", const std::string& shared_name = "");
    tensor unbatch_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor unbatch_grad(const tensor& original_input, const tensor& batch_index, const tensor& grad, const tensor& id, const std::string& container = "", const std::string& shared_name = "");
    tensor unicode_encode(const tensor& input_values, const tensor& input_splits, const std::string& output_encoding, const std::string& errors = "replace", int64_t replacement_char = 65533, datatype Tsplits = static_cast<datatype>(9));
    tensor unicode_script(const tensor& input);
    tensor unicode_transcode(const tensor& input, const std::string& input_encoding, const std::string& output_encoding, const std::string& errors = "replace", int64_t replacement_char = 65533, bool replace_control_characters = false);
    tensor unique_dataset(const tensor& input_dataset, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor unpack(const tensor& value, int64_t num, int64_t axis = 0);
    tensor unravel_index(const tensor& indices, const tensor& dims, datatype Tidx = static_cast<datatype>(3));
    tensor unsorted_segment_join(const tensor& inputs, const tensor& segment_ids, const tensor& num_segments, datatype Tindices, const std::string& separator = "", datatype Tnumsegments = static_cast<datatype>(3));
    tensor unsorted_segment_max(const tensor& data, const tensor& segment_ids, const tensor& num_segments, datatype Tindices, datatype Tnumsegments = static_cast<datatype>(3));
    tensor unsorted_segment_min(const tensor& data, const tensor& segment_ids, const tensor& num_segments, datatype Tindices, datatype Tnumsegments = static_cast<datatype>(3));
    tensor unsorted_segment_prod(const tensor& data, const tensor& segment_ids, const tensor& num_segments, datatype Tindices, datatype Tnumsegments = static_cast<datatype>(3));
    tensor unsorted_segment_sum(const tensor& data, const tensor& segment_ids, const tensor& num_segments, datatype Tindices, datatype Tnumsegments = static_cast<datatype>(3));
    tensor unstage(const std::vector<datatype>& dtypes, int64_t capacity = 0, int64_t memory_limit = 0, const std::string& container = "", const std::string& shared_name = "");
    tensor unwrap_dataset_variant(const tensor& input_handle);
    tensor upper_bound(const tensor& sorted_inputs, const tensor& values, datatype out_type = static_cast<datatype>(3));
    tensor var_handle_op(datatype dtype, const std::vector<int64_t>& shape, const std::vector< std::string>& allowed_devices, const std::string& container = "", const std::string& shared_name = "");
    tensor var_is_initialized_op(const tensor& resource);
    tensor variable(const std::vector<int64_t>& shape, datatype dtype, const std::string& container = "", const std::string& shared_name = "");
    tensor variable_shape(const tensor& input, datatype out_type = static_cast<datatype>(3));
    tensor variable_v2(const std::vector<int64_t>& shape, datatype dtype, const std::string& container = "", const std::string& shared_name = "");
    tensor where(const tensor& input);
    tensor whole_file_reader(const std::string& container = "", const std::string& shared_name = "");
    tensor whole_file_reader_v2(const std::string& container = "", const std::string& shared_name = "");
    tensor window_dataset(const tensor& input_dataset, const tensor& size, const tensor& shift, const tensor& stride, const tensor& drop_remainder, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);
    tensor worker_heartbeat(const tensor& request);
    tensor wrap_dataset_variant(const tensor& input_handle);
    tensor xdivy(const tensor& x, const tensor& y);
    tensor xlog1py(const tensor& x, const tensor& y);
    tensor xlogy(const tensor& x, const tensor& y);
    tensor zeros_like(const tensor& x);
    tensor zeta(const tensor& x, const tensor& q);
    tensor zip_dataset(const std::vector<tensor>& input_datasets, const std::vector<datatype>& output_types, const std::vector< std::vector<int64_t>>& output_shapes);

} // cppflow

#endif

